// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef PROTOBUF_msg_2eproto__INCLUDED
#define PROTOBUF_msg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace db_srv {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_msg_2eproto();
void protobuf_AssignDesc_msg_2eproto();
void protobuf_ShutdownFile_msg_2eproto();

class set;
class set_table;
class set_reply;
class set_reply_table_status;
class get;
class get_reply;
class get_reply_table;
class mget;
class mget_user_table;
class mget_reply;
class mget_reply_user_table;
class lua;

// ===================================================================

class set_table : public ::google::protobuf::Message {
 public:
  set_table();
  virtual ~set_table();
  
  set_table(const set_table& from);
  
  inline set_table& operator=(const set_table& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const set_table& default_instance();
  
  void Swap(set_table* other);
  
  // implements Message ----------------------------------------------
  
  set_table* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const set_table& from);
  void MergeFrom(const set_table& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  
  // required string table_bin = 2;
  inline bool has_table_bin() const;
  inline void clear_table_bin();
  static const int kTableBinFieldNumber = 2;
  inline const ::std::string& table_bin() const;
  inline void set_table_bin(const ::std::string& value);
  inline void set_table_bin(const char* value);
  inline void set_table_bin(const char* value, size_t size);
  inline ::std::string* mutable_table_bin();
  inline ::std::string* release_table_bin();
  
  // @@protoc_insertion_point(class_scope:db_srv.set.table)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_table_bin();
  inline void clear_has_table_bin();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* table_name_;
  ::std::string* table_bin_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static set_table* default_instance_;
};
// -------------------------------------------------------------------

class set : public ::google::protobuf::Message {
 public:
  set();
  virtual ~set();
  
  set(const set& from);
  
  inline set& operator=(const set& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const set& default_instance();
  
  void Swap(set* other);
  
  // implements Message ----------------------------------------------
  
  set* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const set& from);
  void MergeFrom(const set& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef set_table table;
  
  // accessors -------------------------------------------------------
  
  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);
  
  // required string argback = 2;
  inline bool has_argback() const;
  inline void clear_argback();
  static const int kArgbackFieldNumber = 2;
  inline const ::std::string& argback() const;
  inline void set_argback(const ::std::string& value);
  inline void set_argback(const char* value);
  inline void set_argback(const char* value, size_t size);
  inline ::std::string* mutable_argback();
  inline ::std::string* release_argback();
  
  // repeated .db_srv.set.table tables = 3;
  inline int tables_size() const;
  inline void clear_tables();
  static const int kTablesFieldNumber = 3;
  inline const ::db_srv::set_table& tables(int index) const;
  inline ::db_srv::set_table* mutable_tables(int index);
  inline ::db_srv::set_table* add_tables();
  inline const ::google::protobuf::RepeatedPtrField< ::db_srv::set_table >&
      tables() const;
  inline ::google::protobuf::RepeatedPtrField< ::db_srv::set_table >*
      mutable_tables();
  
  // @@protoc_insertion_point(class_scope:db_srv.set)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_argback();
  inline void clear_has_argback();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* argback_;
  ::google::protobuf::RepeatedPtrField< ::db_srv::set_table > tables_;
  ::google::protobuf::int32 uid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static set* default_instance_;
};
// -------------------------------------------------------------------

class set_reply_table_status : public ::google::protobuf::Message {
 public:
  set_reply_table_status();
  virtual ~set_reply_table_status();
  
  set_reply_table_status(const set_reply_table_status& from);
  
  inline set_reply_table_status& operator=(const set_reply_table_status& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const set_reply_table_status& default_instance();
  
  void Swap(set_reply_table_status* other);
  
  // implements Message ----------------------------------------------
  
  set_reply_table_status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const set_reply_table_status& from);
  void MergeFrom(const set_reply_table_status& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  
  // required string status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  
  // @@protoc_insertion_point(class_scope:db_srv.set_reply.table_status)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* table_name_;
  ::std::string* status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static set_reply_table_status* default_instance_;
};
// -------------------------------------------------------------------

class set_reply : public ::google::protobuf::Message {
 public:
  set_reply();
  virtual ~set_reply();
  
  set_reply(const set_reply& from);
  
  inline set_reply& operator=(const set_reply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const set_reply& default_instance();
  
  void Swap(set_reply* other);
  
  // implements Message ----------------------------------------------
  
  set_reply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const set_reply& from);
  void MergeFrom(const set_reply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef set_reply_table_status table_status;
  
  // accessors -------------------------------------------------------
  
  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);
  
  // required string argback = 2;
  inline bool has_argback() const;
  inline void clear_argback();
  static const int kArgbackFieldNumber = 2;
  inline const ::std::string& argback() const;
  inline void set_argback(const ::std::string& value);
  inline void set_argback(const char* value);
  inline void set_argback(const char* value, size_t size);
  inline ::std::string* mutable_argback();
  inline ::std::string* release_argback();
  
  // repeated .db_srv.set_reply.table_status table_statuses = 3;
  inline int table_statuses_size() const;
  inline void clear_table_statuses();
  static const int kTableStatusesFieldNumber = 3;
  inline const ::db_srv::set_reply_table_status& table_statuses(int index) const;
  inline ::db_srv::set_reply_table_status* mutable_table_statuses(int index);
  inline ::db_srv::set_reply_table_status* add_table_statuses();
  inline const ::google::protobuf::RepeatedPtrField< ::db_srv::set_reply_table_status >&
      table_statuses() const;
  inline ::google::protobuf::RepeatedPtrField< ::db_srv::set_reply_table_status >*
      mutable_table_statuses();
  
  // @@protoc_insertion_point(class_scope:db_srv.set_reply)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_argback();
  inline void clear_has_argback();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* argback_;
  ::google::protobuf::RepeatedPtrField< ::db_srv::set_reply_table_status > table_statuses_;
  ::google::protobuf::int32 uid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static set_reply* default_instance_;
};
// -------------------------------------------------------------------

class get : public ::google::protobuf::Message {
 public:
  get();
  virtual ~get();
  
  get(const get& from);
  
  inline get& operator=(const get& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const get& default_instance();
  
  void Swap(get* other);
  
  // implements Message ----------------------------------------------
  
  get* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const get& from);
  void MergeFrom(const get& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);
  
  // required string argback = 2;
  inline bool has_argback() const;
  inline void clear_argback();
  static const int kArgbackFieldNumber = 2;
  inline const ::std::string& argback() const;
  inline void set_argback(const ::std::string& value);
  inline void set_argback(const char* value);
  inline void set_argback(const char* value, size_t size);
  inline ::std::string* mutable_argback();
  inline ::std::string* release_argback();
  
  // repeated string table_name = 3;
  inline int table_name_size() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  inline const ::std::string& table_name(int index) const;
  inline ::std::string* mutable_table_name(int index);
  inline void set_table_name(int index, const ::std::string& value);
  inline void set_table_name(int index, const char* value);
  inline void set_table_name(int index, const char* value, size_t size);
  inline ::std::string* add_table_name();
  inline void add_table_name(const ::std::string& value);
  inline void add_table_name(const char* value);
  inline void add_table_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& table_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_table_name();
  
  // @@protoc_insertion_point(class_scope:db_srv.get)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_argback();
  inline void clear_has_argback();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* argback_;
  ::google::protobuf::RepeatedPtrField< ::std::string> table_name_;
  ::google::protobuf::int32 uid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static get* default_instance_;
};
// -------------------------------------------------------------------

class get_reply_table : public ::google::protobuf::Message {
 public:
  get_reply_table();
  virtual ~get_reply_table();
  
  get_reply_table(const get_reply_table& from);
  
  inline get_reply_table& operator=(const get_reply_table& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const get_reply_table& default_instance();
  
  void Swap(get_reply_table* other);
  
  // implements Message ----------------------------------------------
  
  get_reply_table* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const get_reply_table& from);
  void MergeFrom(const get_reply_table& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  
  // required string table_bin = 2;
  inline bool has_table_bin() const;
  inline void clear_table_bin();
  static const int kTableBinFieldNumber = 2;
  inline const ::std::string& table_bin() const;
  inline void set_table_bin(const ::std::string& value);
  inline void set_table_bin(const char* value);
  inline void set_table_bin(const char* value, size_t size);
  inline ::std::string* mutable_table_bin();
  inline ::std::string* release_table_bin();
  
  // @@protoc_insertion_point(class_scope:db_srv.get_reply.table)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_table_bin();
  inline void clear_has_table_bin();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* table_name_;
  ::std::string* table_bin_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static get_reply_table* default_instance_;
};
// -------------------------------------------------------------------

class get_reply : public ::google::protobuf::Message {
 public:
  get_reply();
  virtual ~get_reply();
  
  get_reply(const get_reply& from);
  
  inline get_reply& operator=(const get_reply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const get_reply& default_instance();
  
  void Swap(get_reply* other);
  
  // implements Message ----------------------------------------------
  
  get_reply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const get_reply& from);
  void MergeFrom(const get_reply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef get_reply_table table;
  
  // accessors -------------------------------------------------------
  
  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);
  
  // required string argback = 2;
  inline bool has_argback() const;
  inline void clear_argback();
  static const int kArgbackFieldNumber = 2;
  inline const ::std::string& argback() const;
  inline void set_argback(const ::std::string& value);
  inline void set_argback(const char* value);
  inline void set_argback(const char* value, size_t size);
  inline ::std::string* mutable_argback();
  inline ::std::string* release_argback();
  
  // repeated .db_srv.get_reply.table tables = 3;
  inline int tables_size() const;
  inline void clear_tables();
  static const int kTablesFieldNumber = 3;
  inline const ::db_srv::get_reply_table& tables(int index) const;
  inline ::db_srv::get_reply_table* mutable_tables(int index);
  inline ::db_srv::get_reply_table* add_tables();
  inline const ::google::protobuf::RepeatedPtrField< ::db_srv::get_reply_table >&
      tables() const;
  inline ::google::protobuf::RepeatedPtrField< ::db_srv::get_reply_table >*
      mutable_tables();
  
  // @@protoc_insertion_point(class_scope:db_srv.get_reply)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_argback();
  inline void clear_has_argback();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* argback_;
  ::google::protobuf::RepeatedPtrField< ::db_srv::get_reply_table > tables_;
  ::google::protobuf::int32 uid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static get_reply* default_instance_;
};
// -------------------------------------------------------------------

class mget_user_table : public ::google::protobuf::Message {
 public:
  mget_user_table();
  virtual ~mget_user_table();
  
  mget_user_table(const mget_user_table& from);
  
  inline mget_user_table& operator=(const mget_user_table& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mget_user_table& default_instance();
  
  void Swap(mget_user_table* other);
  
  // implements Message ----------------------------------------------
  
  mget_user_table* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mget_user_table& from);
  void MergeFrom(const mget_user_table& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);
  
  // required string table_name = 2;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  
  // @@protoc_insertion_point(class_scope:db_srv.mget.user_table)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* table_name_;
  ::google::protobuf::int32 uid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static mget_user_table* default_instance_;
};
// -------------------------------------------------------------------

class mget : public ::google::protobuf::Message {
 public:
  mget();
  virtual ~mget();
  
  mget(const mget& from);
  
  inline mget& operator=(const mget& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mget& default_instance();
  
  void Swap(mget* other);
  
  // implements Message ----------------------------------------------
  
  mget* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mget& from);
  void MergeFrom(const mget& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef mget_user_table user_table;
  
  // accessors -------------------------------------------------------
  
  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);
  
  // required string argback = 2;
  inline bool has_argback() const;
  inline void clear_argback();
  static const int kArgbackFieldNumber = 2;
  inline const ::std::string& argback() const;
  inline void set_argback(const ::std::string& value);
  inline void set_argback(const char* value);
  inline void set_argback(const char* value, size_t size);
  inline ::std::string* mutable_argback();
  inline ::std::string* release_argback();
  
  // repeated .db_srv.mget.user_table user_tables = 3;
  inline int user_tables_size() const;
  inline void clear_user_tables();
  static const int kUserTablesFieldNumber = 3;
  inline const ::db_srv::mget_user_table& user_tables(int index) const;
  inline ::db_srv::mget_user_table* mutable_user_tables(int index);
  inline ::db_srv::mget_user_table* add_user_tables();
  inline const ::google::protobuf::RepeatedPtrField< ::db_srv::mget_user_table >&
      user_tables() const;
  inline ::google::protobuf::RepeatedPtrField< ::db_srv::mget_user_table >*
      mutable_user_tables();
  
  // @@protoc_insertion_point(class_scope:db_srv.mget)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_argback();
  inline void clear_has_argback();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* argback_;
  ::google::protobuf::RepeatedPtrField< ::db_srv::mget_user_table > user_tables_;
  ::google::protobuf::int32 uid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static mget* default_instance_;
};
// -------------------------------------------------------------------

class mget_reply_user_table : public ::google::protobuf::Message {
 public:
  mget_reply_user_table();
  virtual ~mget_reply_user_table();
  
  mget_reply_user_table(const mget_reply_user_table& from);
  
  inline mget_reply_user_table& operator=(const mget_reply_user_table& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mget_reply_user_table& default_instance();
  
  void Swap(mget_reply_user_table* other);
  
  // implements Message ----------------------------------------------
  
  mget_reply_user_table* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mget_reply_user_table& from);
  void MergeFrom(const mget_reply_user_table& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);
  
  // required string table_name = 2;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  
  // required string table_bin = 3;
  inline bool has_table_bin() const;
  inline void clear_table_bin();
  static const int kTableBinFieldNumber = 3;
  inline const ::std::string& table_bin() const;
  inline void set_table_bin(const ::std::string& value);
  inline void set_table_bin(const char* value);
  inline void set_table_bin(const char* value, size_t size);
  inline ::std::string* mutable_table_bin();
  inline ::std::string* release_table_bin();
  
  // @@protoc_insertion_point(class_scope:db_srv.mget_reply.user_table)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_table_bin();
  inline void clear_has_table_bin();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* table_name_;
  ::std::string* table_bin_;
  ::google::protobuf::int32 uid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static mget_reply_user_table* default_instance_;
};
// -------------------------------------------------------------------

class mget_reply : public ::google::protobuf::Message {
 public:
  mget_reply();
  virtual ~mget_reply();
  
  mget_reply(const mget_reply& from);
  
  inline mget_reply& operator=(const mget_reply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mget_reply& default_instance();
  
  void Swap(mget_reply* other);
  
  // implements Message ----------------------------------------------
  
  mget_reply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mget_reply& from);
  void MergeFrom(const mget_reply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef mget_reply_user_table user_table;
  
  // accessors -------------------------------------------------------
  
  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);
  
  // required string argback = 2;
  inline bool has_argback() const;
  inline void clear_argback();
  static const int kArgbackFieldNumber = 2;
  inline const ::std::string& argback() const;
  inline void set_argback(const ::std::string& value);
  inline void set_argback(const char* value);
  inline void set_argback(const char* value, size_t size);
  inline ::std::string* mutable_argback();
  inline ::std::string* release_argback();
  
  // repeated .db_srv.mget_reply.user_table tables = 3;
  inline int tables_size() const;
  inline void clear_tables();
  static const int kTablesFieldNumber = 3;
  inline const ::db_srv::mget_reply_user_table& tables(int index) const;
  inline ::db_srv::mget_reply_user_table* mutable_tables(int index);
  inline ::db_srv::mget_reply_user_table* add_tables();
  inline const ::google::protobuf::RepeatedPtrField< ::db_srv::mget_reply_user_table >&
      tables() const;
  inline ::google::protobuf::RepeatedPtrField< ::db_srv::mget_reply_user_table >*
      mutable_tables();
  
  // @@protoc_insertion_point(class_scope:db_srv.mget_reply)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_argback();
  inline void clear_has_argback();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* argback_;
  ::google::protobuf::RepeatedPtrField< ::db_srv::mget_reply_user_table > tables_;
  ::google::protobuf::int32 uid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static mget_reply* default_instance_;
};
// -------------------------------------------------------------------

class lua : public ::google::protobuf::Message {
 public:
  lua();
  virtual ~lua();
  
  lua(const lua& from);
  
  inline lua& operator=(const lua& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const lua& default_instance();
  
  void Swap(lua* other);
  
  // implements Message ----------------------------------------------
  
  lua* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lua& from);
  void MergeFrom(const lua& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);
  
  // required string argback = 2;
  inline bool has_argback() const;
  inline void clear_argback();
  static const int kArgbackFieldNumber = 2;
  inline const ::std::string& argback() const;
  inline void set_argback(const ::std::string& value);
  inline void set_argback(const char* value);
  inline void set_argback(const char* value, size_t size);
  inline ::std::string* mutable_argback();
  inline ::std::string* release_argback();
  
  // @@protoc_insertion_point(class_scope:db_srv.lua)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_argback();
  inline void clear_has_argback();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* argback_;
  ::google::protobuf::int32 uid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();
  
  void InitAsDefaultInstance();
  static lua* default_instance_;
};
// ===================================================================


// ===================================================================

// set_table

// required string table_name = 1;
inline bool set_table::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void set_table::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void set_table::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void set_table::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& set_table::table_name() const {
  return *table_name_;
}
inline void set_table::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void set_table::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void set_table::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* set_table::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* set_table::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string table_bin = 2;
inline bool set_table::has_table_bin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void set_table::set_has_table_bin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void set_table::clear_has_table_bin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void set_table::clear_table_bin() {
  if (table_bin_ != &::google::protobuf::internal::kEmptyString) {
    table_bin_->clear();
  }
  clear_has_table_bin();
}
inline const ::std::string& set_table::table_bin() const {
  return *table_bin_;
}
inline void set_table::set_table_bin(const ::std::string& value) {
  set_has_table_bin();
  if (table_bin_ == &::google::protobuf::internal::kEmptyString) {
    table_bin_ = new ::std::string;
  }
  table_bin_->assign(value);
}
inline void set_table::set_table_bin(const char* value) {
  set_has_table_bin();
  if (table_bin_ == &::google::protobuf::internal::kEmptyString) {
    table_bin_ = new ::std::string;
  }
  table_bin_->assign(value);
}
inline void set_table::set_table_bin(const char* value, size_t size) {
  set_has_table_bin();
  if (table_bin_ == &::google::protobuf::internal::kEmptyString) {
    table_bin_ = new ::std::string;
  }
  table_bin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* set_table::mutable_table_bin() {
  set_has_table_bin();
  if (table_bin_ == &::google::protobuf::internal::kEmptyString) {
    table_bin_ = new ::std::string;
  }
  return table_bin_;
}
inline ::std::string* set_table::release_table_bin() {
  clear_has_table_bin();
  if (table_bin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_bin_;
    table_bin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// set

// required int32 uid = 1;
inline bool set::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void set::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void set::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void set::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 set::uid() const {
  return uid_;
}
inline void set::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// required string argback = 2;
inline bool set::has_argback() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void set::set_has_argback() {
  _has_bits_[0] |= 0x00000002u;
}
inline void set::clear_has_argback() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void set::clear_argback() {
  if (argback_ != &::google::protobuf::internal::kEmptyString) {
    argback_->clear();
  }
  clear_has_argback();
}
inline const ::std::string& set::argback() const {
  return *argback_;
}
inline void set::set_argback(const ::std::string& value) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(value);
}
inline void set::set_argback(const char* value) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(value);
}
inline void set::set_argback(const char* value, size_t size) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* set::mutable_argback() {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  return argback_;
}
inline ::std::string* set::release_argback() {
  clear_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = argback_;
    argback_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .db_srv.set.table tables = 3;
inline int set::tables_size() const {
  return tables_.size();
}
inline void set::clear_tables() {
  tables_.Clear();
}
inline const ::db_srv::set_table& set::tables(int index) const {
  return tables_.Get(index);
}
inline ::db_srv::set_table* set::mutable_tables(int index) {
  return tables_.Mutable(index);
}
inline ::db_srv::set_table* set::add_tables() {
  return tables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::db_srv::set_table >&
set::tables() const {
  return tables_;
}
inline ::google::protobuf::RepeatedPtrField< ::db_srv::set_table >*
set::mutable_tables() {
  return &tables_;
}

// -------------------------------------------------------------------

// set_reply_table_status

// required string table_name = 1;
inline bool set_reply_table_status::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void set_reply_table_status::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void set_reply_table_status::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void set_reply_table_status::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& set_reply_table_status::table_name() const {
  return *table_name_;
}
inline void set_reply_table_status::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void set_reply_table_status::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void set_reply_table_status::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* set_reply_table_status::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* set_reply_table_status::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string status = 2;
inline bool set_reply_table_status::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void set_reply_table_status::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void set_reply_table_status::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void set_reply_table_status::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& set_reply_table_status::status() const {
  return *status_;
}
inline void set_reply_table_status::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void set_reply_table_status::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void set_reply_table_status::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* set_reply_table_status::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* set_reply_table_status::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// set_reply

// required int32 uid = 1;
inline bool set_reply::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void set_reply::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void set_reply::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void set_reply::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 set_reply::uid() const {
  return uid_;
}
inline void set_reply::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// required string argback = 2;
inline bool set_reply::has_argback() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void set_reply::set_has_argback() {
  _has_bits_[0] |= 0x00000002u;
}
inline void set_reply::clear_has_argback() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void set_reply::clear_argback() {
  if (argback_ != &::google::protobuf::internal::kEmptyString) {
    argback_->clear();
  }
  clear_has_argback();
}
inline const ::std::string& set_reply::argback() const {
  return *argback_;
}
inline void set_reply::set_argback(const ::std::string& value) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(value);
}
inline void set_reply::set_argback(const char* value) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(value);
}
inline void set_reply::set_argback(const char* value, size_t size) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* set_reply::mutable_argback() {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  return argback_;
}
inline ::std::string* set_reply::release_argback() {
  clear_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = argback_;
    argback_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .db_srv.set_reply.table_status table_statuses = 3;
inline int set_reply::table_statuses_size() const {
  return table_statuses_.size();
}
inline void set_reply::clear_table_statuses() {
  table_statuses_.Clear();
}
inline const ::db_srv::set_reply_table_status& set_reply::table_statuses(int index) const {
  return table_statuses_.Get(index);
}
inline ::db_srv::set_reply_table_status* set_reply::mutable_table_statuses(int index) {
  return table_statuses_.Mutable(index);
}
inline ::db_srv::set_reply_table_status* set_reply::add_table_statuses() {
  return table_statuses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::db_srv::set_reply_table_status >&
set_reply::table_statuses() const {
  return table_statuses_;
}
inline ::google::protobuf::RepeatedPtrField< ::db_srv::set_reply_table_status >*
set_reply::mutable_table_statuses() {
  return &table_statuses_;
}

// -------------------------------------------------------------------

// get

// required int32 uid = 1;
inline bool get::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void get::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void get::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void get::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 get::uid() const {
  return uid_;
}
inline void get::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// required string argback = 2;
inline bool get::has_argback() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void get::set_has_argback() {
  _has_bits_[0] |= 0x00000002u;
}
inline void get::clear_has_argback() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void get::clear_argback() {
  if (argback_ != &::google::protobuf::internal::kEmptyString) {
    argback_->clear();
  }
  clear_has_argback();
}
inline const ::std::string& get::argback() const {
  return *argback_;
}
inline void get::set_argback(const ::std::string& value) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(value);
}
inline void get::set_argback(const char* value) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(value);
}
inline void get::set_argback(const char* value, size_t size) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* get::mutable_argback() {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  return argback_;
}
inline ::std::string* get::release_argback() {
  clear_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = argback_;
    argback_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string table_name = 3;
inline int get::table_name_size() const {
  return table_name_.size();
}
inline void get::clear_table_name() {
  table_name_.Clear();
}
inline const ::std::string& get::table_name(int index) const {
  return table_name_.Get(index);
}
inline ::std::string* get::mutable_table_name(int index) {
  return table_name_.Mutable(index);
}
inline void get::set_table_name(int index, const ::std::string& value) {
  table_name_.Mutable(index)->assign(value);
}
inline void get::set_table_name(int index, const char* value) {
  table_name_.Mutable(index)->assign(value);
}
inline void get::set_table_name(int index, const char* value, size_t size) {
  table_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* get::add_table_name() {
  return table_name_.Add();
}
inline void get::add_table_name(const ::std::string& value) {
  table_name_.Add()->assign(value);
}
inline void get::add_table_name(const char* value) {
  table_name_.Add()->assign(value);
}
inline void get::add_table_name(const char* value, size_t size) {
  table_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
get::table_name() const {
  return table_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
get::mutable_table_name() {
  return &table_name_;
}

// -------------------------------------------------------------------

// get_reply_table

// required string table_name = 1;
inline bool get_reply_table::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void get_reply_table::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void get_reply_table::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void get_reply_table::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& get_reply_table::table_name() const {
  return *table_name_;
}
inline void get_reply_table::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void get_reply_table::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void get_reply_table::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* get_reply_table::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* get_reply_table::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string table_bin = 2;
inline bool get_reply_table::has_table_bin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void get_reply_table::set_has_table_bin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void get_reply_table::clear_has_table_bin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void get_reply_table::clear_table_bin() {
  if (table_bin_ != &::google::protobuf::internal::kEmptyString) {
    table_bin_->clear();
  }
  clear_has_table_bin();
}
inline const ::std::string& get_reply_table::table_bin() const {
  return *table_bin_;
}
inline void get_reply_table::set_table_bin(const ::std::string& value) {
  set_has_table_bin();
  if (table_bin_ == &::google::protobuf::internal::kEmptyString) {
    table_bin_ = new ::std::string;
  }
  table_bin_->assign(value);
}
inline void get_reply_table::set_table_bin(const char* value) {
  set_has_table_bin();
  if (table_bin_ == &::google::protobuf::internal::kEmptyString) {
    table_bin_ = new ::std::string;
  }
  table_bin_->assign(value);
}
inline void get_reply_table::set_table_bin(const char* value, size_t size) {
  set_has_table_bin();
  if (table_bin_ == &::google::protobuf::internal::kEmptyString) {
    table_bin_ = new ::std::string;
  }
  table_bin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* get_reply_table::mutable_table_bin() {
  set_has_table_bin();
  if (table_bin_ == &::google::protobuf::internal::kEmptyString) {
    table_bin_ = new ::std::string;
  }
  return table_bin_;
}
inline ::std::string* get_reply_table::release_table_bin() {
  clear_has_table_bin();
  if (table_bin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_bin_;
    table_bin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// get_reply

// required int32 uid = 1;
inline bool get_reply::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void get_reply::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void get_reply::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void get_reply::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 get_reply::uid() const {
  return uid_;
}
inline void get_reply::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// required string argback = 2;
inline bool get_reply::has_argback() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void get_reply::set_has_argback() {
  _has_bits_[0] |= 0x00000002u;
}
inline void get_reply::clear_has_argback() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void get_reply::clear_argback() {
  if (argback_ != &::google::protobuf::internal::kEmptyString) {
    argback_->clear();
  }
  clear_has_argback();
}
inline const ::std::string& get_reply::argback() const {
  return *argback_;
}
inline void get_reply::set_argback(const ::std::string& value) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(value);
}
inline void get_reply::set_argback(const char* value) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(value);
}
inline void get_reply::set_argback(const char* value, size_t size) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* get_reply::mutable_argback() {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  return argback_;
}
inline ::std::string* get_reply::release_argback() {
  clear_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = argback_;
    argback_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .db_srv.get_reply.table tables = 3;
inline int get_reply::tables_size() const {
  return tables_.size();
}
inline void get_reply::clear_tables() {
  tables_.Clear();
}
inline const ::db_srv::get_reply_table& get_reply::tables(int index) const {
  return tables_.Get(index);
}
inline ::db_srv::get_reply_table* get_reply::mutable_tables(int index) {
  return tables_.Mutable(index);
}
inline ::db_srv::get_reply_table* get_reply::add_tables() {
  return tables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::db_srv::get_reply_table >&
get_reply::tables() const {
  return tables_;
}
inline ::google::protobuf::RepeatedPtrField< ::db_srv::get_reply_table >*
get_reply::mutable_tables() {
  return &tables_;
}

// -------------------------------------------------------------------

// mget_user_table

// required int32 uid = 1;
inline bool mget_user_table::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mget_user_table::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mget_user_table::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mget_user_table::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 mget_user_table::uid() const {
  return uid_;
}
inline void mget_user_table::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// required string table_name = 2;
inline bool mget_user_table::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mget_user_table::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mget_user_table::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mget_user_table::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& mget_user_table::table_name() const {
  return *table_name_;
}
inline void mget_user_table::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void mget_user_table::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void mget_user_table::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mget_user_table::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* mget_user_table::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// mget

// required int32 uid = 1;
inline bool mget::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mget::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mget::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mget::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 mget::uid() const {
  return uid_;
}
inline void mget::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// required string argback = 2;
inline bool mget::has_argback() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mget::set_has_argback() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mget::clear_has_argback() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mget::clear_argback() {
  if (argback_ != &::google::protobuf::internal::kEmptyString) {
    argback_->clear();
  }
  clear_has_argback();
}
inline const ::std::string& mget::argback() const {
  return *argback_;
}
inline void mget::set_argback(const ::std::string& value) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(value);
}
inline void mget::set_argback(const char* value) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(value);
}
inline void mget::set_argback(const char* value, size_t size) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mget::mutable_argback() {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  return argback_;
}
inline ::std::string* mget::release_argback() {
  clear_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = argback_;
    argback_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .db_srv.mget.user_table user_tables = 3;
inline int mget::user_tables_size() const {
  return user_tables_.size();
}
inline void mget::clear_user_tables() {
  user_tables_.Clear();
}
inline const ::db_srv::mget_user_table& mget::user_tables(int index) const {
  return user_tables_.Get(index);
}
inline ::db_srv::mget_user_table* mget::mutable_user_tables(int index) {
  return user_tables_.Mutable(index);
}
inline ::db_srv::mget_user_table* mget::add_user_tables() {
  return user_tables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::db_srv::mget_user_table >&
mget::user_tables() const {
  return user_tables_;
}
inline ::google::protobuf::RepeatedPtrField< ::db_srv::mget_user_table >*
mget::mutable_user_tables() {
  return &user_tables_;
}

// -------------------------------------------------------------------

// mget_reply_user_table

// required int32 uid = 1;
inline bool mget_reply_user_table::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mget_reply_user_table::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mget_reply_user_table::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mget_reply_user_table::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 mget_reply_user_table::uid() const {
  return uid_;
}
inline void mget_reply_user_table::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// required string table_name = 2;
inline bool mget_reply_user_table::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mget_reply_user_table::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mget_reply_user_table::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mget_reply_user_table::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& mget_reply_user_table::table_name() const {
  return *table_name_;
}
inline void mget_reply_user_table::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void mget_reply_user_table::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void mget_reply_user_table::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mget_reply_user_table::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* mget_reply_user_table::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string table_bin = 3;
inline bool mget_reply_user_table::has_table_bin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mget_reply_user_table::set_has_table_bin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mget_reply_user_table::clear_has_table_bin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mget_reply_user_table::clear_table_bin() {
  if (table_bin_ != &::google::protobuf::internal::kEmptyString) {
    table_bin_->clear();
  }
  clear_has_table_bin();
}
inline const ::std::string& mget_reply_user_table::table_bin() const {
  return *table_bin_;
}
inline void mget_reply_user_table::set_table_bin(const ::std::string& value) {
  set_has_table_bin();
  if (table_bin_ == &::google::protobuf::internal::kEmptyString) {
    table_bin_ = new ::std::string;
  }
  table_bin_->assign(value);
}
inline void mget_reply_user_table::set_table_bin(const char* value) {
  set_has_table_bin();
  if (table_bin_ == &::google::protobuf::internal::kEmptyString) {
    table_bin_ = new ::std::string;
  }
  table_bin_->assign(value);
}
inline void mget_reply_user_table::set_table_bin(const char* value, size_t size) {
  set_has_table_bin();
  if (table_bin_ == &::google::protobuf::internal::kEmptyString) {
    table_bin_ = new ::std::string;
  }
  table_bin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mget_reply_user_table::mutable_table_bin() {
  set_has_table_bin();
  if (table_bin_ == &::google::protobuf::internal::kEmptyString) {
    table_bin_ = new ::std::string;
  }
  return table_bin_;
}
inline ::std::string* mget_reply_user_table::release_table_bin() {
  clear_has_table_bin();
  if (table_bin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_bin_;
    table_bin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// mget_reply

// required int32 uid = 1;
inline bool mget_reply::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mget_reply::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mget_reply::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mget_reply::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 mget_reply::uid() const {
  return uid_;
}
inline void mget_reply::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// required string argback = 2;
inline bool mget_reply::has_argback() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mget_reply::set_has_argback() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mget_reply::clear_has_argback() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mget_reply::clear_argback() {
  if (argback_ != &::google::protobuf::internal::kEmptyString) {
    argback_->clear();
  }
  clear_has_argback();
}
inline const ::std::string& mget_reply::argback() const {
  return *argback_;
}
inline void mget_reply::set_argback(const ::std::string& value) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(value);
}
inline void mget_reply::set_argback(const char* value) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(value);
}
inline void mget_reply::set_argback(const char* value, size_t size) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mget_reply::mutable_argback() {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  return argback_;
}
inline ::std::string* mget_reply::release_argback() {
  clear_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = argback_;
    argback_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .db_srv.mget_reply.user_table tables = 3;
inline int mget_reply::tables_size() const {
  return tables_.size();
}
inline void mget_reply::clear_tables() {
  tables_.Clear();
}
inline const ::db_srv::mget_reply_user_table& mget_reply::tables(int index) const {
  return tables_.Get(index);
}
inline ::db_srv::mget_reply_user_table* mget_reply::mutable_tables(int index) {
  return tables_.Mutable(index);
}
inline ::db_srv::mget_reply_user_table* mget_reply::add_tables() {
  return tables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::db_srv::mget_reply_user_table >&
mget_reply::tables() const {
  return tables_;
}
inline ::google::protobuf::RepeatedPtrField< ::db_srv::mget_reply_user_table >*
mget_reply::mutable_tables() {
  return &tables_;
}

// -------------------------------------------------------------------

// lua

// required int32 uid = 1;
inline bool lua::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lua::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lua::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lua::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 lua::uid() const {
  return uid_;
}
inline void lua::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// required string argback = 2;
inline bool lua::has_argback() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lua::set_has_argback() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lua::clear_has_argback() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lua::clear_argback() {
  if (argback_ != &::google::protobuf::internal::kEmptyString) {
    argback_->clear();
  }
  clear_has_argback();
}
inline const ::std::string& lua::argback() const {
  return *argback_;
}
inline void lua::set_argback(const ::std::string& value) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(value);
}
inline void lua::set_argback(const char* value) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(value);
}
inline void lua::set_argback(const char* value, size_t size) {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  argback_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* lua::mutable_argback() {
  set_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    argback_ = new ::std::string;
  }
  return argback_;
}
inline ::std::string* lua::release_argback() {
  clear_has_argback();
  if (argback_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = argback_;
    argback_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace db_srv

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_msg_2eproto__INCLUDED
